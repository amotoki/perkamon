diff --git a/man2/recv.2 b/man2/recv.2
index 9ddcc30..c9ae879 100644
--- a/man2/recv.2
+++ b/man2/recv.2
@@ -330,7 +330,7 @@ The caller should set
 .I msg_namelen
 to the size of this buffer before this call;
 upon return from a successful call,
-.I msg_name
+.I msg_namelen
 will contain the length of the returned address.
 If the application does not need to know the source address,
 .I msg_name
diff --git a/man2/recvmmsg.2 b/man2/recvmmsg.2
index 7e9bda9..afe6714 100644
--- a/man2/recvmmsg.2
+++ b/man2/recvmmsg.2
@@ -33,7 +33,7 @@
 recvmmsg \- receive multiple messages on a socket
 .SH SYNOPSIS
 .nf
-.B "#define _GNU_SOURCE" "         /* See feature_test_macros(7) */"
+.BR "#define _GNU_SOURCE" "         /* See feature_test_macros(7) */"
 .BI "#include <sys/socket.h>"
 
 .BI "int recvmmsg(int " sockfd ", struct mmsghdr *" msgvec \
diff --git a/man2/semop.2 b/man2/semop.2
index b8f91a1..7e76994 100644
--- a/man2/semop.2
+++ b/man2/semop.2
@@ -439,7 +439,7 @@ the corresponding
 .I semadj
 values in all processes are cleared.
 The
-.BR clone ()
+.BR clone (2)
 .B CLONE_SYSVSEM
 flag allows more than one process to share a
 .I semadj
diff --git a/man2/sendmmsg.2 b/man2/sendmmsg.2
index 15fa03b..ece4805 100644
--- a/man2/sendmmsg.2
+++ b/man2/sendmmsg.2
@@ -30,7 +30,7 @@
 sendmmsg \- send multiple messages on a socket
 .SH SYNOPSIS
 .nf
-.B "#define _GNU_SOURCE" "         /* See feature_test_macros(7) */"
+.BR "#define _GNU_SOURCE" "         /* See feature_test_macros(7) */"
 .BI "#include <sys/socket.h>"
 
 .BI "int sendmmsg(int " sockfd ", struct mmsghdr *" msgvec \
diff --git a/man2/shmget.2 b/man2/shmget.2
index ce3ff5b..e90fef7 100644
--- a/man2/shmget.2
+++ b/man2/shmget.2
@@ -209,7 +209,7 @@ but a shared memory segment already exists for
 A new segment was to be created and
 .I size
 is less than
-.B SHMIN
+.B SHMMIN
 or greater than
 .BR SHMMAX .
 .TP
@@ -283,9 +283,7 @@ The following limits on shared memory segment resources affect the
 call:
 .TP
 .B SHMALL
-System-wide limit on the number of
-.I pages
-of shared memory.
+System-wide limit on the number of pages of shared memory.
 
 On Linux, this limit can be read and modified via
 .IR /proc/sys/kernel/shmall .
diff --git a/man3/mq_getattr.3 b/man3/mq_getattr.3
index 2a792c2..681b5f1 100644
--- a/man3/mq_getattr.3
+++ b/man3/mq_getattr.3
@@ -90,7 +90,7 @@ Both of these fields must have a value greater than zero.
 Two
 .I /proc
 files that place ceilings on the values for these fields are described in
-.BR mq_overview (3).
+.BR mq_overview (7).
 
 The
 .I mq_curmsgs
@@ -187,7 +187,7 @@ $ \fBcat /proc/sys/fs/mqueue/msgsize_default\fP
 8192
 .fi
 .in
-.SS Program course
+.SS Program source
 \&
 .nf
 #include <mqueue.h>
diff --git a/man3/ilogb.3 b/man3/ilogb.3
index ce975dd..6f02e7a 100644
--- a/man3/ilogb.3
+++ b/man3/ilogb.3
@@ -145,7 +145,7 @@ functions are thread-safe.
 C99, POSIX.1-2001.
 .SH BUGS
 .\" Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6794
-Before version 2.16, the following bugs xisted in the
+Before version 2.16, the following bugs existed in the
 glibc implementation of these functions:
 .IP * 3
 The domain error case where
diff --git a/man2/statfs.2 b/man2/statfs.2
index 490d96d..8269a19 100644
--- a/man2/statfs.2
+++ b/man2/statfs.2
@@ -143,8 +143,8 @@ Filesystem types:
 .in
 .PP
 Most of these MAGIC constants are defined in
-.I /usr/include/linux/magic.h
-some are hardcoded in kernel sources.
+.IR /usr/include/linux/magic.h ,
+and some are hardcoded in kernel sources.
 .PP
 Nobody knows what
 .I f_fsid
diff --git a/man2/readlink.2 b/man2/readlink.2
index 41523b8..720fa99 100644
--- a/man2/readlink.2
+++ b/man2/readlink.2
@@ -138,7 +138,7 @@ Since Linux 2.6.39,
 can be an empty string,
 in which case the call operates on the symbolic link referred to by
 .IR dirfd
-(which should have have been obtained using
+(which should have been obtained using
 .BR open (2)
 with the
 .B O_PATH
diff --git a/man2/setsid.2 b/man2/setsid.2
index cff8e22..ee9abac 100644
--- a/man2/setsid.2
+++ b/man2/setsid.2
@@ -76,7 +76,7 @@ The session ID is preserved across an
 
 A process group leader is a process whose process group ID equals its PID.
 Disallowing a process group leader from calling
-.BR setsid()
+.BR setsid ()
 prevents the possibility that a process group leader places itself
 in a new session while other processes in the process group remain
 in the original session;
